"""Classes for handling and communication with processes in pseudo terminals."""
import errno
import struct
import termios
import fcntl
import pty
import os


class ProcessFinished(Exception):
    """The process has finished finished."""


class Process:
    """A class repsesenting a process executing in a pseudo terminal."""

    def __init__(self,
                 executable: str,
                 args: list[str],
                 columns: int = 80,
                 lines: int = 24) -> None:
        """Initialize a Process object

        Args:
            executable (str): Executable to run. Must be either full path or present in path.
            args (list[str]): List of arguments to send to the process.
            columns (int, optional): Width of the pseudo terminal. Defaults to 80.
            lines (int, optional): Height of the pseudo terminal. Defaults to 24.
        """

        self._lines = lines
        self._columns = columns

        pid, self._child_fd = pty.fork()

        # Parent and child will continue executing the same code
        # but get different return values. Parent gets the actual
        # pid of the child, while the child gets zero.
        if pid == 0:
            env = {
                "TERM": "linux",
                "COLUMNS": str(columns),
                "LINES": str(lines),
            }
            # This replaces the python process in child
            os.execvpe(executable, [executable, *args], env=env)

        # See "man ioctl_tty for details"
        terminal_size = struct.pack('HHHH', lines, columns, 0, 0)
        fcntl.ioctl(self._child_fd, termios.TIOCSWINSZ, terminal_size)

        os.set_blocking(self._child_fd, False)

    def get_new_output(self, max_size: int = 1024) -> bytes:
        """Get any output generated inside the terminal after the last call to this function.

        Args:
            max_size (int, optional): Maximum amount of data to return. Defaults to 1024.

        Raises:
            ProcessFinished: If the process has finished and there is no more output to read.

        Returns:
            bytes: The output generated by the process.
        """
        # End of file signalling seems to be platform dependent and could
        # either be an empty value or an IO error. Hard to find any
        # reasonable source confirming this. The best I could find:
        # https://github.com/pexpect/pexpect/blob/6e2bbd5568fb8468c176c2c9b7f20d4f4bf7dd71/pexpect/spawnbase.py#L182
        # https://stackoverflow.com/questions/10238298/ruby-on-linux-pty-goes-away-without-eof-raises-errnoeio
        # So, essentially, handle both as an EOF.
        try:
            data = os.read(self._child_fd, max_size)
        except BlockingIOError:
            return b""
        except OSError as e:
            if e.args[0] == errno.EIO:
                # End of file reached, original error irrelevant
                # pylint: disable-next=raise-missing-from
                raise ProcessFinished()

        if not data:
            raise ProcessFinished()

        return data

    @property
    def lines(self) -> int:
        """Number of lines in the pseudo terminal.

        Returns:
            int: Number of lines in the pseudo terminal.
        """
        return self._lines

    @property
    def columns(self) -> int:
        """Number of columns in the pseudo terminal.

        Returns:
            int: Number of columns in the pseudo terminal.
        """
        return self._columns
